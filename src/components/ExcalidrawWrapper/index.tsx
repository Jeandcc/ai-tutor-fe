import React, { useEffect, useRef, useState } from "react";
import { ShieldQuestion } from "lucide-react";

import {
  convertToExcalidrawElements,
  Excalidraw,
  WelcomeScreen,
} from "@excalidraw/excalidraw";
import "@excalidraw/excalidraw/index.css";
import { ExcalidrawImperativeAPI } from "@excalidraw/excalidraw/types";

import {
  useLocalParticipant,
  useConnectionState,
} from "@livekit/components-react";
import { ConnectionState, Track } from "livekit-client";
import Image from "next/image";
import { useRouter } from "next/router";
import { useConfig } from "@/hooks/useConfig";
import { Button } from "../ui/button";

/**
 * Extracts simplified data about visible elements on the Excalidraw canvas.
 * @param excalidrawAPI - The imperative API instance for Excalidraw.
 * @returns An object containing simplified element data and basic app state, or null if API is unavailable.
 */
export const getSimplifiedCanvasData = (
  excalidrawAPI: ExcalidrawImperativeAPI | null
) => {
  if (!excalidrawAPI) {
    console.error("Excalidraw API not available.");
    return null;
  }

  const elements = excalidrawAPI.getSceneElements();
  const appState = excalidrawAPI.getAppState();

  // Filter out deleted elements and simplify the data
  const simplifiedElements = elements
    .filter((el) => !el.isDeleted)
    .map((el) => {
      const simplified: any = {
        id: el.id,
        type: el.type,
        x: Math.round(el.x), // Use integers for simplicity
        y: Math.round(el.y),
        width: Math.round(el.width),
        height: Math.round(el.height),
      };
      // Include text content if available
      if ("text" in el && typeof el.text === "string") {
        simplified.text = el.text;
      }
      // Include points for lines/arrows if available
      if ("points" in el && Array.isArray(el.points)) {
        simplified.points = el.points.map((p) => [
          Math.round(p[0]),
          Math.round(p[1]),
        ]);
      }
      return simplified;
    });

  const simplifiedAppState = {
    width: appState.width,
    height: appState.height,
    scrollX: appState.scrollX,
    scrollY: appState.scrollY,
    zoom: appState.zoom.value,
  };

  return {
    elements: simplifiedElements,
    appState: simplifiedAppState,
  };
};

/**
 * Adds elements generated by the AI to the Excalidraw canvas.
 * Assumes elementsToAdd is an array of objects that can be processed by convertToExcalidrawElements.
 * @param elementsToAdd - An array of element-like objects received from the AI.
 * @param excalidrawAPI - The imperative API instance for Excalidraw.
 */
export const addAiElementsToCanvas = (
  elementsToAdd: any[] | null, // Accept any array, as AI output might be raw JSON
  excalidrawAPI: ExcalidrawImperativeAPI | null
) => {
  if (!excalidrawAPI) {
    console.error("Excalidraw API not available for adding elements.");
    return;
  }

  if (
    !elementsToAdd ||
    !Array.isArray(elementsToAdd) ||
    elementsToAdd.length === 0
  ) {
    console.warn("No valid elements provided by AI to add.");
    return;
  }

  try {
    // IMPORTANT: Use convertToExcalidrawElements to ensure the objects
    // have the correct structure and default values expected by Excalidraw.
    // This adds resilience against slightly malformed AI output.
    const properlyFormedElements = convertToExcalidrawElements(elementsToAdd);

    const alreadyExistingElements = excalidrawAPI.getSceneElements();
    const allElements = [...alreadyExistingElements, ...properlyFormedElements];

    console.log("Adding AI elements:", properlyFormedElements);

    excalidrawAPI.updateScene({
      elements: allElements,
    });

    // Optional: Pan/zoom to the newly added elements
    // excalidrawAPI.zoomToElements(properlyFormedElements);
  } catch (error) {
    console.error("Error processing or adding AI elements:", error);
    // Handle potential errors during conversion or adding
  }
};

const ExcalidrawWrapper: React.FC = () => {
  const [excalidrawAPI, setExcalidrawAPI] = useState<ExcalidrawImperativeAPI>();

  const excalidrawContainerRef = useRef<HTMLDivElement>(null);
  const publishingCanvasRef = useRef<HTMLCanvasElement>(null);
  const shouldUpdatePublishingCanvasRef = useRef(false);
  const prevCanvasStateRef = useRef<string>("");

  const publishingMediaStreamTrackRef = useRef<MediaStreamTrack | null>(null);

  const { localParticipant } = useLocalParticipant();
  const roomState = useConnectionState();

  const canvasUpdateIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // Effect to handle publishing the canvas track when connected,
  // and cleaning up when disconnected or unmounted.
  useEffect(() => {
    const updatePublishingCanvas = async () => {
      if (
        !excalidrawContainerRef.current ||
        !publishingCanvasRef.current ||
        !shouldUpdatePublishingCanvasRef.current
      )
        return;

      // Copies the current Excalidraw canvas to the hidden canvas.
      const ctx = publishingCanvasRef.current.getContext("2d");
      if (ctx) {
        ctx.clearRect(
          0,
          0,
          publishingCanvasRef.current.width,
          publishingCanvasRef.current.height
        );
        ctx.drawImage(
          excalidrawContainerRef.current.querySelector(
            "canvas"
          ) as HTMLCanvasElement,
          0,
          0,
          publishingCanvasRef.current.width,
          publishingCanvasRef.current.height
        );

        shouldUpdatePublishingCanvasRef.current = false;
      }
    };

    const setupMediaStreamIfNotAlreadyUp = () => {
      // If connected, set up the hidden canvas dimensions.
      if (
        publishingCanvasRef.current &&
        !publishingMediaStreamTrackRef.current
      ) {
        // Capture the canvas stream (30 fps is used here; adjust if needed)
        const stream = publishingCanvasRef.current.captureStream(30);
        const track = stream.getVideoTracks()[0];

        // Publish the captured video track with a custom name.
        localParticipant.publishTrack(track, {
          name: "excalidraw",
          source: Track.Source.Unknown,
        });

        publishingMediaStreamTrackRef.current = track;
      }
    };

    const clearMediaStream = () => {
      if (publishingMediaStreamTrackRef.current) {
        localParticipant.unpublishTrack(publishingMediaStreamTrackRef.current);
        publishingMediaStreamTrackRef.current.stop();
        publishingMediaStreamTrackRef.current = null;
      }
    };

    const setupCanvasUpdateIntervalIfNotAlreadyUp = () => {
      // Start the interval to update the publishing canvas if the Excalidraw API is available.
      if (!canvasUpdateIntervalRef.current) {
        canvasUpdateIntervalRef.current = setInterval(
          updatePublishingCanvas,
          1000 / 30
        );
      }
    };

    const clearCanvasUpdateInterval = () => {
      // Clear the interval if it exists.
      if (canvasUpdateIntervalRef.current) {
        clearInterval(canvasUpdateIntervalRef.current);
        canvasUpdateIntervalRef.current = null;
      }
    };

    const cleanup = () => {
      clearMediaStream();
      clearCanvasUpdateInterval();
    };

    // When the room is not connected, cleanup any published track and clear the update interval.
    if (roomState !== ConnectionState.Connected) {
      cleanup();
      return;
    }

    setupMediaStreamIfNotAlreadyUp();
    setupCanvasUpdateIntervalIfNotAlreadyUp();

    // Cleanup function: clear the interval and unpublish the track.
    return () => {
      cleanup();
    };
  }, [roomState, localParticipant]);

  const { query } = useRouter();
  const tutorName =
    query.tutor === "ondre" ? "Ondre" : query.tutor === "ryan" ? "Ryan" : "";

  useEffect(() => {
    if (
      excalidrawAPI &&
      localParticipant &&
      roomState === ConnectionState.Connected
    ) {
      const unsubscribeFromChanges = excalidrawAPI.onChange((_, state) => {
        const newStateJson = JSON.stringify(state);
        const prevStateJson = prevCanvasStateRef.current;

        const newStateObj = state;
        const prevStateObj = JSON.parse(prevStateJson || "{}");

        if (newStateJson === prevStateJson) {
          return;
        } else {
          // const differentProps = findWhatObjPropsOfObjectsAreDifferent(
          //   prevStateObj,
          //   newStateObj
          // );

          const PROPERTIES_TO_TRIGGER_INTERRUPTS = [
            "editingTextElement" as const,
            "newElement" as const,
          ];

          const shouldTriggerInterrupt = PROPERTIES_TO_TRIGGER_INTERRUPTS.some(
            (property) => {
              return newStateObj[property] !== prevStateObj[property];
            }
          );

          if (shouldTriggerInterrupt) {
            localParticipant.sendText("interrupt", {
              topic: "excalidraw",
            });
          }

          prevCanvasStateRef.current = newStateJson;
          shouldUpdatePublishingCanvasRef.current = true;
        }
      });

      return unsubscribeFromChanges;
    }
  }, [excalidrawAPI, localParticipant, roomState]);

  const { config } = useConfig();

  const handleGetContextForAi = () => {
    if (!excalidrawAPI) return null;

    const canvasData = getSimplifiedCanvasData(excalidrawAPI);
    if (canvasData) {
      const canvasDataString = JSON.stringify(canvasData);
      console.log(canvasDataString);
    }
  };

  const handleAiResponse = (aiResponseJsonString: string) => {
    if (!excalidrawAPI) return null;

    try {
      const aiElements = JSON.parse(aiResponseJsonString);
      addAiElementsToCanvas(aiElements, excalidrawAPI);
    } catch (error) {
      console.error("Failed to parse AI response JSON:", error);
    }
  };

  return (
    <>
      <div className="flex flex-col items-center justify-center p-4">
        <Button onClick={handleGetContextForAi} className="mb-4">
          Get Canvas Context for AI
        </Button>

        {/* Input field and submit button to paste json of ai-generated elements  */}
        <div className="flex flex-col gap-2 w-full max-w-md">
          <textarea
            placeholder="Paste AI-generated elements JSON here"
            className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
            rows={4}
            onChange={(e) => handleAiResponse(e.target.value)}
          ></textarea>

          <Button onClick={() => handleAiResponse("")}>
            Add AI Elements to Canvas
          </Button>
        </div>
      </div>

      <div style={{ height: "100%", width: "100%" }}>
        <div
          ref={excalidrawContainerRef}
          style={{ height: "100%", width: "100%" }}
        >
          <Excalidraw excalidrawAPI={(api) => setExcalidrawAPI(api)}>
            <WelcomeScreen>
              <WelcomeScreen.Center>
                <WelcomeScreen.Center.Logo>
                  <Image
                    src="https://cdn.prod.website-files.com/600f0ea5652fe47991474630/602428438327a78cb4e7fcb3_learnerlogo.svg"
                    alt="Learner Logo"
                    width={200}
                    height={200}
                  />
                </WelcomeScreen.Center.Logo>

                <div className="flex flex-col max-w-xl gap-3">
                  <WelcomeScreen.Center.Heading>
                    AI Tutor{tutorName ? ` - ${tutorName}` : ""}
                  </WelcomeScreen.Center.Heading>

                  <WelcomeScreen.Center.Heading>
                    {config.description}
                  </WelcomeScreen.Center.Heading>
                </div>

                <WelcomeScreen.Center.Menu>
                  {/* <WelcomeScreen.Center.MenuItemLink
                  icon={<ShieldQuestion size={20} />}
                  href="https://www.notion.so/Guide-page-1c10b86d6e8e80ef99e9f853aced27e3?pvs=4"
                >
                  How to use the tool
                </WelcomeScreen.Center.MenuItemLink> */}

                  <WelcomeScreen.Center.MenuItemHelp />
                </WelcomeScreen.Center.Menu>
              </WelcomeScreen.Center>

              <WelcomeScreen.Hints.MenuHint />
              <WelcomeScreen.Hints.ToolbarHint />
              <WelcomeScreen.Hints.HelpHint />
            </WelcomeScreen>
          </Excalidraw>
        </div>

        {/* Hidden canvas used to publish the video track */}
        <canvas ref={publishingCanvasRef} style={{ display: "none" }} />
      </div>
    </>
  );
};

export default ExcalidrawWrapper;
